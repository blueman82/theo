conductor:
  worktree_groups:
    - group_id: "storage-layer"
      tasks: [1, 2]
      rationale: "Schema and storage must be in place before hooks can write traces"
    - group_id: "daemon-integration"
      tasks: [3]
      rationale: "Daemon needs session tracking endpoint for hooks to query"
    - group_id: "git-hooks"
      tasks: [4, 5]
      rationale: "Post-commit hook depends on daemon and storage being ready"
    - group_id: "cli-and-mcp"
      tasks: [6, 7]
      rationale: "Query interfaces depend on storage layer"
    - group_id: "testing"
      tasks: [8]
      rationale: "Integration tests run after all components are implemented"

planner_compliance:
  planner_version: "5.0.0"
  strict_enforcement: true
  required_features: [dependency_checks, test_commands, success_criteria, data_flow_registry]

data_flow_registry:
  producers:
    traces_table: [{task: 1, description: "Creates traces table schema in SQLite"}]
    trace_store_methods: [{task: 2, description: "Creates add_trace(), get_trace(), list_traces_for_conversation()"}]
    active_session_endpoint: [{task: 3, description: "Creates get_active_session daemon command"}]
    session_tracking: [{task: 4, description: "Creates session tracking in theo-session-start.py"}]
    commit_hook: [{task: 5, description: "Creates theo-commit-hook.py that writes traces"}]
    trace_config: [{task: 1, description: "Creates THEO_TRACE_ENABLED, THEO_TRACE_GIT_NOTES config"}]
  consumers:
    traces_table:
      - {task: 2, description: "Storage methods use traces table"}
      - {task: 5, description: "Commit hook writes to traces table"}
    trace_store_methods:
      - {task: 5, description: "Commit hook calls add_trace()"}
      - {task: 6, description: "CLI query uses get_trace()"}
      - {task: 7, description: "MCP tools use storage methods"}
    active_session_endpoint:
      - {task: 5, description: "Commit hook queries active session"}
    session_tracking:
      - {task: 5, description: "Commit hook reads session state"}
    trace_config:
      - {task: 5, description: "Commit hook reads config to decide git notes"}

plan:
  metadata:
    feature_name: "Agent Trace - AI Code Attribution"
    created: "2026-02-04"
    target: "Track AI code attribution via commit annotation, linking commits to Claude conversations"
    project_root: "/Users/harrison/Documents/Github/theo-agent-trace"

  context:
    framework: "Python 3.11, asyncio, Unix sockets"
    test_framework: "pytest"
    quality_tool: "./check --fix"
    design_decisions: |
      - Commit-level annotation (not line-level) - let git blame handle line attribution
      - Dual storage: SQLite (queryable) + git notes (portable)
      - Default both on, single config to disable git notes
      - Post-commit hook queries Theo daemon for active session
      - Session state file tracks transcript path and model ID

  tasks:
    - task_number: "1"
      name: "Add traces table and config"
      agent: "python-pro"
      files:
        - "src/theo/storage/sqlite_store.py"
        - "src/theo/config.py"
      depends_on: []

      success_criteria:
        - "traces table created with columns: commit_sha (PK), conversation_url, model_id, session_id, files (JSON), created_at"
        - "Index idx_traces_session on session_id column"
        - "TheoSettings has trace_enabled: bool = True"
        - "TheoSettings has trace_git_notes: bool = True"
        - "./check --fix passes"

      test_commands:
        - "cd /Users/harrison/Documents/Github/theo && ./check --fix"
        - "cd /Users/harrison/Documents/Github/theo && uv run pytest tests/test_sqlite_store.py -v -k 'trace or schema'"

      runtime_metadata:
        dependency_checks:
          - command: "grep 'CREATE TABLE.*traces' src/theo/storage/sqlite_store.py"
            description: "Verify traces table exists"
        documentation_targets: []

      description: |
        <mandatory_principles>
        ENGINEERING: YAGNI, KISS, DRY, Fail Fast, SSOT, Law of Demeter.
        PYTHON:
          - PEP 8: snake_case functions, PascalCase classes, UPPER_CASE constants
          - Full type hints on ALL signatures (Pyright strict)
          - Explicit imports (no star imports, no lazy imports, no TYPE_CHECKING)
          - Context managers for resources
          - f-strings, list comprehensions where readable
        CODE REDUCTION:
          - No helpers for one-time ops
          - Delete unused code completely
        QUALITY: Run ./check --fix before committing
        </mandatory_principles>

        <task_description>
        Add the traces table to SQLiteStore._init_schema() and config fields to TheoSettings.

        In src/theo/storage/sqlite_store.py, add to _init_schema():
        ```python
        # Traces table for Agent Trace (commit attribution)
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS traces (
                commit_sha TEXT PRIMARY KEY,
                conversation_url TEXT NOT NULL,
                model_id TEXT,
                session_id TEXT,
                files TEXT,
                created_at REAL NOT NULL
            )
        """
        )

        cursor.execute(
            """
            CREATE INDEX IF NOT EXISTS idx_traces_session
            ON traces(session_id)
        """
        )
        ```

        In src/theo/config.py, add to TheoSettings:
        ```python
        # Agent Trace configuration
        trace_enabled: bool = Field(default=True, description="Enable AI code attribution tracking")
        trace_git_notes: bool = Field(default=True, description="Write traces to git notes for portability")
        ```

        Run ./check --fix after changes.
        </task_description>

      implementation:
        approach: "Add schema migration and config fields"
        key_points:
          - point: "traces table"
            details: "commit_sha PK, conversation_url, model_id, session_id, files JSON, created_at"
            reference: "src/theo/storage/sqlite_store.py:_init_schema"
          - point: "idx_traces_session"
            details: "Index on session_id for efficient session-based queries"
            reference: "src/theo/storage/sqlite_store.py:_init_schema"
          - point: "trace_enabled"
            details: "Master switch for Agent Trace feature"
            reference: "src/theo/config.py:TheoSettings"
          - point: "trace_git_notes"
            details: "Toggle for git notes portability"
            reference: "src/theo/config.py:TheoSettings"

      code_quality:
        python:
          full_quality_pipeline:
            command: "cd /Users/harrison/Documents/Github/theo && ./check --fix"
            exit_on_failure: true

      commit:
        type: "feat"
        message: "Add traces table schema and config for Agent Trace"
        files: ["src/theo/storage/**", "src/theo/config.py"]

    - task_number: "2"
      name: "Add trace storage methods"
      agent: "python-pro"
      files:
        - "src/theo/storage/sqlite_store.py"
      depends_on: ["1"]

      success_criteria:
        - "add_trace(commit_sha, conversation_url, model_id, session_id, files) method exists"
        - "get_trace(commit_sha) returns TraceRecord or None"
        - "list_traces_for_conversation(conversation_url) returns list[TraceRecord]"
        - "TraceRecord dataclass with commit_sha, conversation_url, model_id, session_id, files, created_at"
        - "./check --fix passes"

      test_commands:
        - "cd /Users/harrison/Documents/Github/theo && ./check --fix"
        - "cd /Users/harrison/Documents/Github/theo && uv run pytest tests/test_sqlite_store.py -v -k trace"

      runtime_metadata:
        dependency_checks:
          - command: "grep 'def add_trace' src/theo/storage/sqlite_store.py"
            description: "Verify add_trace method exists"
        documentation_targets: []

      description: |
        <mandatory_principles>
        ENGINEERING: YAGNI, KISS, DRY, Fail Fast, SSOT, Law of Demeter.
        PYTHON:
          - PEP 8: snake_case functions, PascalCase classes, UPPER_CASE constants
          - Full type hints on ALL signatures (Pyright strict)
          - Explicit imports (no star imports, no lazy imports, no TYPE_CHECKING)
          - Context managers for resources
          - f-strings, list comprehensions where readable
        CODE REDUCTION:
          - No helpers for one-time ops
          - Delete unused code completely
        QUALITY: Run ./check --fix before committing
        </mandatory_principles>

        <task_description>
        Add TraceRecord dataclass and CRUD methods to SQLiteStore.

        Add near the top of the file (after SearchResult):
        ```python
        @dataclass
        class TraceRecord:
            """Record of AI attribution for a git commit."""
            commit_sha: str
            conversation_url: str
            model_id: str | None
            session_id: str | None
            files: list[str]
            created_at: float
        ```

        Add methods to SQLiteStore class:
        ```python
        def add_trace(
            self,
            commit_sha: str,
            conversation_url: str,
            model_id: str | None = None,
            session_id: str | None = None,
            files: list[str] | None = None,
        ) -> None:
            """Record AI attribution for a git commit.

            Args:
                commit_sha: Git commit SHA
                conversation_url: Path to conversation transcript
                model_id: AI model identifier (e.g., "anthropic/claude-opus-4-5-20251101")
                session_id: Claude Code session ID
                files: List of files changed in commit
            """
            cursor = self._conn.cursor()
            cursor.execute(
                """
                INSERT OR REPLACE INTO traces
                (commit_sha, conversation_url, model_id, session_id, files, created_at)
                VALUES (?, ?, ?, ?, ?, ?)
                """,
                (
                    commit_sha,
                    conversation_url,
                    model_id,
                    session_id,
                    json.dumps(files or []),
                    time.time(),
                ),
            )
            self._conn.commit()

        def get_trace(self, commit_sha: str) -> TraceRecord | None:
            """Get trace record for a commit.

            Args:
                commit_sha: Git commit SHA

            Returns:
                TraceRecord or None if not found
            """
            cursor = self._conn.cursor()
            cursor.execute(
                "SELECT * FROM traces WHERE commit_sha = ?",
                (commit_sha,),
            )
            row = cursor.fetchone()
            if row is None:
                return None
            return TraceRecord(
                commit_sha=row["commit_sha"],
                conversation_url=row["conversation_url"],
                model_id=row["model_id"],
                session_id=row["session_id"],
                files=json.loads(row["files"]) if row["files"] else [],
                created_at=row["created_at"],
            )

        def list_traces_for_conversation(self, conversation_url: str) -> list[TraceRecord]:
            """List all traces for a conversation.

            Args:
                conversation_url: Conversation transcript path

            Returns:
                List of TraceRecord objects
            """
            cursor = self._conn.cursor()
            cursor.execute(
                "SELECT * FROM traces WHERE conversation_url = ? ORDER BY created_at",
                (conversation_url,),
            )
            return [
                TraceRecord(
                    commit_sha=row["commit_sha"],
                    conversation_url=row["conversation_url"],
                    model_id=row["model_id"],
                    session_id=row["session_id"],
                    files=json.loads(row["files"]) if row["files"] else [],
                    created_at=row["created_at"],
                )
                for row in cursor.fetchall()
            ]
        ```

        Run ./check --fix after changes.
        </task_description>

      implementation:
        approach: "Add dataclass and CRUD methods following existing patterns"
        key_points:
          - point: "TraceRecord"
            details: "Dataclass with commit_sha, conversation_url, model_id, session_id, files, created_at"
            reference: "src/theo/storage/sqlite_store.py"
          - point: "add_trace"
            details: "INSERT OR REPLACE into traces table with JSON-serialized files list"
            reference: "src/theo/storage/sqlite_store.py:SQLiteStore"
          - point: "get_trace"
            details: "SELECT by commit_sha, returns TraceRecord or None"
            reference: "src/theo/storage/sqlite_store.py:SQLiteStore"
          - point: "list_traces_for_conversation"
            details: "SELECT by conversation_url, returns list of TraceRecord"
            reference: "src/theo/storage/sqlite_store.py:SQLiteStore"

      code_quality:
        python:
          full_quality_pipeline:
            command: "cd /Users/harrison/Documents/Github/theo && ./check --fix"
            exit_on_failure: true

      commit:
        type: "feat"
        message: "Add trace storage methods to SQLiteStore"
        files: ["src/theo/storage/**"]

    - task_number: "3"
      name: "Add get_active_session daemon command"
      agent: "python-pro"
      files:
        - "src/theo/daemon/protocol.py"
        - "src/theo/daemon/server.py"
      depends_on: []

      success_criteria:
        - "DaemonCommand.GET_ACTIVE_SESSION = 'get_active_session' enum value added"
        - "_handle_get_active_session method returns session_id, transcript_path, model_id, project_path"
        - "Handler registered in _dispatch handlers dict"
        - "./check --fix passes"

      test_commands:
        - "cd /Users/harrison/Documents/Github/theo && ./check --fix"
        - "cd /Users/harrison/Documents/Github/theo && uv run pytest tests/test_daemon.py -v"

      runtime_metadata:
        dependency_checks:
          - command: "grep 'get_active_session' src/theo/daemon/protocol.py"
            description: "Verify command enum exists"
        documentation_targets: []

      description: |
        <mandatory_principles>
        ENGINEERING: YAGNI, KISS, DRY, Fail Fast, SSOT, Law of Demeter.
        PYTHON:
          - PEP 8: snake_case functions, PascalCase classes, UPPER_CASE constants
          - Full type hints on ALL signatures (Pyright strict)
          - Explicit imports (no star imports, no lazy imports, no TYPE_CHECKING)
        CODE REDUCTION:
          - No helpers for one-time ops
        QUALITY: Run ./check --fix before committing
        </mandatory_principles>

        <task_description>
        Add daemon command for querying active Claude Code session.

        In src/theo/daemon/protocol.py, add to DaemonCommand enum:
        ```python
        # Session tracking for Agent Trace
        GET_ACTIVE_SESSION = "get_active_session"
        ```

        In src/theo/daemon/server.py, the server needs to track active sessions.
        Add instance variable in __init__:
        ```python
        self._active_session: dict[str, Any] | None = None
        ```

        Add method to set active session (called by hooks via daemon client):
        ```python
        async def _handle_set_active_session(self, request: DaemonRequest) -> DaemonResponse:
            """Set the currently active Claude Code session."""
            args = request.args
            self._active_session = {
                "session_id": args.get("session_id"),
                "transcript_path": args.get("transcript_path"),
                "model_id": args.get("model_id"),
                "project_path": args.get("project_path"),
                "started_at": datetime.now().isoformat(),
            }
            return DaemonResponse.ok(
                {"status": "active_session_set"},
                request_id=request.request_id,
            )

        async def _handle_get_active_session(self, request: DaemonRequest) -> DaemonResponse:
            """Get the currently active Claude Code session."""
            if self._active_session is None:
                return DaemonResponse.ok(
                    {"active": False, "session": None},
                    request_id=request.request_id,
                )
            return DaemonResponse.ok(
                {"active": True, "session": self._active_session},
                request_id=request.request_id,
            )
        ```

        Add to _dispatch handlers dict:
        ```python
        "set_active_session": self._handle_set_active_session,
        "get_active_session": self._handle_get_active_session,
        ```

        Also add SET_ACTIVE_SESSION to DaemonCommand enum.

        Run ./check --fix after changes.
        </task_description>

      implementation:
        approach: "Add daemon command and handler following existing patterns"
        key_points:
          - point: "GET_ACTIVE_SESSION"
            details: "DaemonCommand enum value for querying active session"
            reference: "src/theo/daemon/protocol.py:DaemonCommand"
          - point: "_active_session"
            details: "Instance variable tracking current session (session_id, transcript_path, model_id, project_path)"
            reference: "src/theo/daemon/server.py:DaemonServer.__init__"
          - point: "_handle_get_active_session"
            details: "Returns active: bool and session dict"
            reference: "src/theo/daemon/server.py:DaemonServer"
          - point: "_handle_set_active_session"
            details: "Sets _active_session from args"
            reference: "src/theo/daemon/server.py:DaemonServer"

      code_quality:
        python:
          full_quality_pipeline:
            command: "cd /Users/harrison/Documents/Github/theo && ./check --fix"
            exit_on_failure: true

      commit:
        type: "feat"
        message: "Add get_active_session daemon command for Agent Trace"
        files: ["src/theo/daemon/**"]

    - task_number: "4"
      name: "Update session start hook to register with daemon"
      agent: "python-pro"
      files:
        - "hooks/theo-session-start.py"
      depends_on: ["3"]

      success_criteria:
        - "Hook calls daemon set_active_session with session_id, transcript_path, model_id, project_path"
        - "Uses existing theo_client.DaemonClient for daemon communication"
        - "Gracefully handles daemon not running"
        - "./check --fix passes"

      test_commands:
        - "cd /Users/harrison/Documents/Github/theo && ./check --fix"

      runtime_metadata:
        dependency_checks:
          - command: "grep 'set_active_session' hooks/theo-session-start.py"
            description: "Verify hook registers session"
        documentation_targets: []

      description: |
        <mandatory_principles>
        ENGINEERING: YAGNI, KISS, DRY, Fail Fast, SSOT, Law of Demeter.
        PYTHON:
          - PEP 8: snake_case functions, PascalCase classes, UPPER_CASE constants
          - Full type hints on ALL signatures (Pyright strict)
        QUALITY: Run ./check --fix before committing
        </mandatory_principles>

        <task_description>
        Update theo-session-start.py to register the active session with the Theo daemon.

        After existing session initialization logic, add:
        ```python
        def register_session_with_daemon(
            session_id: str,
            transcript_path: str,
            project_path: str,
        ) -> None:
            """Register session with Theo daemon for Agent Trace."""
            try:
                from theo_client import DaemonClient

                # Extract model from transcript if available
                model_id = None
                transcript = Path(transcript_path)
                if transcript.exists():
                    # Read first few lines to find model
                    with transcript.open() as f:
                        for line in f:
                            if '"model"' in line:
                                import json
                                try:
                                    entry = json.loads(line)
                                    model_id = entry.get("model")
                                    break
                                except json.JSONDecodeError:
                                    pass

                with DaemonClient() as client:
                    client.send_command(
                        "set_active_session",
                        {
                            "session_id": session_id,
                            "transcript_path": transcript_path,
                            "model_id": model_id,
                            "project_path": project_path,
                        },
                    )
            except Exception:
                pass  # Don't fail hook if daemon not running
        ```

        Call this function in main() after session state is initialized.

        Run ./check --fix after changes.
        </task_description>

      implementation:
        approach: "Add daemon registration after existing session init"
        key_points:
          - point: "register_session_with_daemon"
            details: "Sends set_active_session command to daemon with session_id, transcript_path, model_id, project_path"
            reference: "hooks/theo-session-start.py"
          - point: "model extraction"
            details: "Parses transcript JSON to find model ID"
            reference: "hooks/theo-session-start.py:register_session_with_daemon"
          - point: "graceful failure"
            details: "Catches all exceptions to not fail hook if daemon unavailable"
            reference: "hooks/theo-session-start.py:register_session_with_daemon"

      code_quality:
        python:
          full_quality_pipeline:
            command: "cd /Users/harrison/Documents/Github/theo && ./check --fix"
            exit_on_failure: true

      commit:
        type: "feat"
        message: "Register session with daemon on start for Agent Trace"
        files: ["hooks/theo-session-start.py"]

    - task_number: "5"
      name: "Create git post-commit hook"
      agent: "python-pro"
      files:
        - "hooks/theo-commit-hook.py"
      depends_on: ["1", "2", "3", "4"]

      success_criteria:
        - "theo-commit-hook.py is executable post-commit hook"
        - "Queries daemon for active session via get_active_session"
        - "Gets commit SHA and files from git"
        - "Writes trace to SQLite via SQLiteStore.add_trace()"
        - "Writes git notes if THEO_TRACE_GIT_NOTES=true"
        - "Gracefully handles no active session (human commit)"
        - "./check --fix passes"

      test_commands:
        - "cd /Users/harrison/Documents/Github/theo && ./check --fix"
        - "cd /Users/harrison/Documents/Github/theo && python hooks/theo-commit-hook.py --help || true"

      runtime_metadata:
        dependency_checks:
          - command: "test -f hooks/theo-commit-hook.py"
            description: "Verify hook file exists"
        documentation_targets: []

      description: |
        <mandatory_principles>
        ENGINEERING: YAGNI, KISS, DRY, Fail Fast, SSOT, Law of Demeter.
        PYTHON:
          - PEP 8: snake_case functions, PascalCase classes, UPPER_CASE constants
          - Full type hints on ALL signatures (Pyright strict)
          - Explicit imports (no star imports, no lazy imports, no TYPE_CHECKING)
        CODE REDUCTION:
          - No helpers for one-time ops
        QUALITY: Run ./check --fix before committing
        </mandatory_principles>

        <task_description>
        Create the git post-commit hook for Agent Trace.

        Create hooks/theo-commit-hook.py:
        ```python
        #!/usr/bin/env python3
        """Git post-commit hook for Agent Trace.

        Records AI attribution by linking commits to Claude conversations.
        Queries Theo daemon for active session and stores trace in SQLite.
        Optionally writes git notes for portability.
        """

        import json
        import os
        import subprocess
        import sys
        from pathlib import Path

        # Add hooks directory to path for imports
        sys.path.insert(0, str(Path(__file__).parent))


        def get_commit_info() -> tuple[str, list[str]] | None:
            """Get current commit SHA and changed files."""
            try:
                sha = subprocess.run(
                    ["git", "rev-parse", "HEAD"],
                    capture_output=True,
                    text=True,
                    check=True,
                ).stdout.strip()

                files = subprocess.run(
                    ["git", "diff-tree", "--no-commit-id", "--name-only", "-r", "HEAD"],
                    capture_output=True,
                    text=True,
                    check=True,
                ).stdout.strip().split("\n")

                return sha, [f for f in files if f]
            except subprocess.CalledProcessError:
                return None


        def get_active_session() -> dict | None:
            """Query Theo daemon for active Claude session."""
            try:
                from theo_client import DaemonClient

                with DaemonClient() as client:
                    response = client.send_command("get_active_session", {})
                    if response.get("success") and response.get("data", {}).get("active"):
                        return response["data"]["session"]
            except Exception:
                pass
            return None


        def write_trace(
            commit_sha: str,
            conversation_url: str,
            model_id: str | None,
            session_id: str | None,
            files: list[str],
        ) -> bool:
            """Write trace to SQLite storage."""
            try:
                from theo.storage.sqlite_store import SQLiteStore

                store = SQLiteStore()
                store.add_trace(
                    commit_sha=commit_sha,
                    conversation_url=conversation_url,
                    model_id=model_id,
                    session_id=session_id,
                    files=files,
                )
                return True
            except Exception as e:
                print(f"Failed to write trace: {e}", file=sys.stderr)
                return False


        def write_git_note(commit_sha: str, conversation_url: str, model_id: str | None) -> bool:
            """Write git note with attribution info."""
            note_content = json.dumps({
                "agent_trace": {
                    "conversation": conversation_url,
                    "model": model_id,
                }
            })
            try:
                subprocess.run(
                    ["git", "notes", "add", "-f", "-m", note_content, commit_sha],
                    capture_output=True,
                    check=True,
                )
                return True
            except subprocess.CalledProcessError:
                return False


        def main() -> int:
            """Main entry point for post-commit hook."""
            # Check if tracing is enabled
            if os.environ.get("THEO_TRACE_ENABLED", "true").lower() == "false":
                return 0

            # Get commit info
            commit_info = get_commit_info()
            if commit_info is None:
                return 0

            commit_sha, files = commit_info

            # Get active session from daemon
            session = get_active_session()
            if session is None:
                # No active Claude session - human commit, skip
                return 0

            # Write trace to SQLite
            write_trace(
                commit_sha=commit_sha,
                conversation_url=session.get("transcript_path", ""),
                model_id=session.get("model_id"),
                session_id=session.get("session_id"),
                files=files,
            )

            # Optionally write git notes
            if os.environ.get("THEO_TRACE_GIT_NOTES", "true").lower() == "true":
                write_git_note(
                    commit_sha=commit_sha,
                    conversation_url=session.get("transcript_path", ""),
                    model_id=session.get("model_id"),
                )

            return 0


        if __name__ == "__main__":
            sys.exit(main())
        ```

        Make it executable: chmod +x hooks/theo-commit-hook.py

        Run ./check --fix after changes.
        </task_description>

      implementation:
        approach: "Create standalone post-commit hook script"
        key_points:
          - point: "get_commit_info"
            details: "Uses git rev-parse HEAD and git diff-tree to get SHA and files"
            reference: "hooks/theo-commit-hook.py"
          - point: "get_active_session"
            details: "Queries daemon via theo_client.DaemonClient"
            reference: "hooks/theo-commit-hook.py"
          - point: "write_trace"
            details: "Uses SQLiteStore.add_trace() to persist"
            reference: "hooks/theo-commit-hook.py"
          - point: "write_git_note"
            details: "Uses git notes add with JSON content"
            reference: "hooks/theo-commit-hook.py"
          - point: "THEO_TRACE_ENABLED check"
            details: "Respects master switch env var"
            reference: "hooks/theo-commit-hook.py:main"
          - point: "THEO_TRACE_GIT_NOTES check"
            details: "Respects git notes toggle env var"
            reference: "hooks/theo-commit-hook.py:main"

      code_quality:
        python:
          full_quality_pipeline:
            command: "cd /Users/harrison/Documents/Github/theo && ./check --fix"
            exit_on_failure: true

      commit:
        type: "feat"
        message: "Add git post-commit hook for Agent Trace"
        files: ["hooks/theo-commit-hook.py"]

    - task_number: "6"
      name: "Add CLI commands for trace query"
      agent: "python-pro"
      files:
        - "src/theo/__main__.py"
      depends_on: ["2"]

      success_criteria:
        - "'theo trace query <file> [--line N]' command exists"
        - "'theo trace init' command exists to install git hook"
        - "Query runs git blame, looks up commit in traces table"
        - "Returns conversation URL if found, or 'No AI attribution' message"
        - "./check --fix passes"

      test_commands:
        - "cd /Users/harrison/Documents/Github/theo && ./check --fix"
        - "cd /Users/harrison/Documents/Github/theo && uv run python -m theo --help"

      runtime_metadata:
        dependency_checks:
          - command: "grep 'trace' src/theo/__main__.py"
            description: "Verify trace commands exist"
        documentation_targets: []

      description: |
        <mandatory_principles>
        ENGINEERING: YAGNI, KISS, DRY, Fail Fast, SSOT, Law of Demeter.
        PYTHON:
          - PEP 8: snake_case functions, PascalCase classes, UPPER_CASE constants
          - Full type hints on ALL signatures (Pyright strict)
        CODE REDUCTION:
          - No helpers for one-time ops
        QUALITY: Run ./check --fix before committing
        </mandatory_principles>

        <task_description>
        Add CLI subcommands for Agent Trace.

        Extend the existing CLI in __main__.py to add trace commands.
        If using click/typer, add a trace group. If using argparse, add subparsers.

        Commands needed:

        1. `theo trace init` - Install git hook
           - Creates symlink from .git/hooks/post-commit to hooks/theo-commit-hook.py
           - Or copies the hook if symlink not possible
           - Prints success message

        2. `theo trace query <file> [--line N]` - Query attribution
           - Runs `git blame -L N,N <file>` if line specified, else `git blame <file>`
           - Extracts commit SHA from blame output
           - Looks up commit in traces table
           - If found: prints conversation URL
           - If not found: prints "No AI attribution found for this code"

        Example implementation (adapt to existing CLI pattern):
        ```python
        def trace_init() -> None:
            """Install Agent Trace git hook."""
            import shutil

            git_dir = Path(".git")
            if not git_dir.exists():
                print("Error: Not a git repository", file=sys.stderr)
                sys.exit(1)

            hook_src = Path(__file__).parent.parent.parent / "hooks" / "theo-commit-hook.py"
            hook_dst = git_dir / "hooks" / "post-commit"

            if hook_dst.exists():
                print(f"Warning: {hook_dst} already exists, backing up...")
                shutil.move(hook_dst, hook_dst.with_suffix(".backup"))

            shutil.copy(hook_src, hook_dst)
            hook_dst.chmod(0o755)
            print(f"Installed Agent Trace hook to {hook_dst}")


        def trace_query(file: str, line: int | None = None) -> None:
            """Query AI attribution for code."""
            import subprocess

            blame_cmd = ["git", "blame", "--porcelain"]
            if line is not None:
                blame_cmd.extend(["-L", f"{line},{line}"])
            blame_cmd.append(file)

            try:
                result = subprocess.run(blame_cmd, capture_output=True, text=True, check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error running git blame: {e.stderr}", file=sys.stderr)
                sys.exit(1)

            # Extract commit SHA (first 40 chars of first line)
            commit_sha = result.stdout.split()[0][:40]

            from theo.storage.sqlite_store import SQLiteStore
            store = SQLiteStore()
            trace = store.get_trace(commit_sha)

            if trace:
                print(f"AI Attribution Found:")
                print(f"  Conversation: {trace.conversation_url}")
                print(f"  Model: {trace.model_id or 'unknown'}")
                print(f"  Commit: {commit_sha[:8]}")
            else:
                print("No AI attribution found for this code")
        ```

        Run ./check --fix after changes.
        </task_description>

      implementation:
        approach: "Add trace subcommand group to existing CLI"
        key_points:
          - point: "'theo trace init' command"
            details: "Copies hook to .git/hooks/post-commit and chmod +x"
            reference: "src/theo/__main__.py"
          - point: "'theo trace query' command"
            details: "git blame --porcelain, extract SHA, lookup in SQLiteStore"
            reference: "src/theo/__main__.py"
          - point: "Query runs git blame"
            details: "Uses --porcelain format for machine parsing"
            reference: "src/theo/__main__.py:trace_query"
          - point: "conversation URL if found"
            details: "Returns conversation URL or 'No AI attribution' message"
            reference: "src/theo/__main__.py"

      code_quality:
        python:
          full_quality_pipeline:
            command: "cd /Users/harrison/Documents/Github/theo && ./check --fix"
            exit_on_failure: true

      commit:
        type: "feat"
        message: "Add trace CLI commands for query and init"
        files: ["src/theo/__main__.py"]

    - task_number: "7"
      name: "Add MCP tools for trace operations"
      agent: "python-pro"
      files:
        - "src/theo/mcp_server.py"
      depends_on: ["2"]

      success_criteria:
        - "trace_query MCP tool exists with file and optional line parameters"
        - "trace_list MCP tool exists with optional conversation_url filter"
        - "Tools use SQLiteStore trace methods"
        - "./check --fix passes"

      test_commands:
        - "cd /Users/harrison/Documents/Github/theo && ./check --fix"
        - "cd /Users/harrison/Documents/Github/theo && uv run pytest tests/test_mcp_server.py -v -k trace"

      runtime_metadata:
        dependency_checks:
          - command: "grep 'trace_query' src/theo/mcp_server.py"
            description: "Verify MCP tools exist"
        documentation_targets: []

      description: |
        <mandatory_principles>
        ENGINEERING: YAGNI, KISS, DRY, Fail Fast, SSOT, Law of Demeter.
        PYTHON:
          - PEP 8: snake_case functions, PascalCase classes, UPPER_CASE constants
          - Full type hints on ALL signatures (Pyright strict)
        CODE REDUCTION:
          - No helpers for one-time ops
        QUALITY: Run ./check --fix before committing
        </mandatory_principles>

        <task_description>
        Add MCP tools for querying traces.

        Add to mcp_server.py following existing tool patterns:

        ```python
        @mcp.tool()
        def trace_query(file: str, line: int | None = None) -> dict:
            """Query AI attribution for code in a file.

            Args:
                file: Path to file to query
                line: Optional line number to query specific line

            Returns:
                Attribution info if found, or message if no attribution
            """
            import subprocess

            blame_cmd = ["git", "blame", "--porcelain"]
            if line is not None:
                blame_cmd.extend(["-L", f"{line},{line}"])
            blame_cmd.append(file)

            try:
                result = subprocess.run(blame_cmd, capture_output=True, text=True, check=True)
            except subprocess.CalledProcessError:
                return {"success": False, "error": "Failed to run git blame"}

            commit_sha = result.stdout.split()[0][:40]

            trace = store.get_trace(commit_sha)
            if trace:
                return {
                    "success": True,
                    "found": True,
                    "commit": commit_sha,
                    "conversation_url": trace.conversation_url,
                    "model_id": trace.model_id,
                    "files": trace.files,
                }
            return {
                "success": True,
                "found": False,
                "commit": commit_sha,
                "message": "No AI attribution found",
            }


        @mcp.tool()
        def trace_list(conversation_url: str | None = None, limit: int = 20) -> dict:
            """List recorded traces.

            Args:
                conversation_url: Filter by conversation (optional)
                limit: Maximum traces to return

            Returns:
                List of trace records
            """
            if conversation_url:
                traces = store.list_traces_for_conversation(conversation_url)
            else:
                # Need to add list_traces method or query directly
                cursor = store._conn.cursor()
                cursor.execute(
                    "SELECT * FROM traces ORDER BY created_at DESC LIMIT ?",
                    (limit,),
                )
                traces = [
                    {
                        "commit_sha": row["commit_sha"],
                        "conversation_url": row["conversation_url"],
                        "model_id": row["model_id"],
                        "files": json.loads(row["files"]) if row["files"] else [],
                    }
                    for row in cursor.fetchall()
                ]

            return {
                "success": True,
                "traces": traces[:limit],
                "count": len(traces),
            }
        ```

        Run ./check --fix after changes.
        </task_description>

      implementation:
        approach: "Add MCP tools following existing FastMCP patterns"
        key_points:
          - point: "trace_query"
            details: "MCP tool wrapping git blame + SQLite lookup"
            reference: "src/theo/mcp_server.py"
          - point: "trace_list"
            details: "MCP tool for listing traces with optional filter"
            reference: "src/theo/mcp_server.py"

      code_quality:
        python:
          full_quality_pipeline:
            command: "cd /Users/harrison/Documents/Github/theo && ./check --fix"
            exit_on_failure: true

      commit:
        type: "feat"
        message: "Add MCP tools for Agent Trace queries"
        files: ["src/theo/mcp_server.py"]

    - task_number: "8"
      name: "Add integration tests for Agent Trace"
      agent: "test-automator"
      files:
        - "tests/test_agent_trace.py"
      depends_on: ["1", "2", "3", "5"]

      success_criteria:
        - "test_trace_storage tests add_trace and get_trace"
        - "test_trace_list_by_conversation tests list_traces_for_conversation"
        - "test_commit_hook_script tests theo-commit-hook.py can be imported"
        - "test_daemon_active_session tests get_active_session command"
        - "./check --fix passes"
        - "All tests pass with uv run pytest tests/test_agent_trace.py -v"

      test_commands:
        - "cd /Users/harrison/Documents/Github/theo && ./check --fix"
        - "cd /Users/harrison/Documents/Github/theo && uv run pytest tests/test_agent_trace.py -v"

      runtime_metadata:
        dependency_checks:
          - command: "test -f tests/test_agent_trace.py"
            description: "Verify test file exists"
        documentation_targets: []

      description: |
        <mandatory_principles>
        ENGINEERING: YAGNI, KISS, DRY, Fail Fast, SSOT, Law of Demeter.
        PYTHON:
          - PEP 8: snake_case functions, PascalCase classes, UPPER_CASE constants
          - Full type hints on ALL signatures (Pyright strict)
        CODE REDUCTION:
          - No helpers for one-time ops
        QUALITY: Run ./check --fix before committing
        </mandatory_principles>

        <task_description>
        Create integration tests for Agent Trace feature.

        Create tests/test_agent_trace.py:
        ```python
        """Tests for Agent Trace feature."""

        import json
        import pytest
        from pathlib import Path


        class TestTraceStorage:
            """Tests for trace storage in SQLiteStore."""

            def test_add_trace(self, temp_sqlite):
                """Test adding a trace record."""
                from theo.storage.sqlite_store import SQLiteStore

                store = SQLiteStore(temp_sqlite)
                store.add_trace(
                    commit_sha="abc123def456",
                    conversation_url="/path/to/transcript.jsonl",
                    model_id="anthropic/claude-opus-4-5-20251101",
                    session_id="test-session-123",
                    files=["src/foo.py", "src/bar.py"],
                )

                trace = store.get_trace("abc123def456")
                assert trace is not None
                assert trace.commit_sha == "abc123def456"
                assert trace.conversation_url == "/path/to/transcript.jsonl"
                assert trace.model_id == "anthropic/claude-opus-4-5-20251101"
                assert trace.files == ["src/foo.py", "src/bar.py"]

            def test_get_trace_not_found(self, temp_sqlite):
                """Test getting non-existent trace returns None."""
                from theo.storage.sqlite_store import SQLiteStore

                store = SQLiteStore(temp_sqlite)
                trace = store.get_trace("nonexistent")
                assert trace is None

            def test_list_traces_by_conversation(self, temp_sqlite):
                """Test listing traces for a conversation."""
                from theo.storage.sqlite_store import SQLiteStore

                store = SQLiteStore(temp_sqlite)

                # Add multiple traces for same conversation
                store.add_trace(
                    commit_sha="commit1",
                    conversation_url="/path/to/conv1.jsonl",
                    files=["a.py"],
                )
                store.add_trace(
                    commit_sha="commit2",
                    conversation_url="/path/to/conv1.jsonl",
                    files=["b.py"],
                )
                store.add_trace(
                    commit_sha="commit3",
                    conversation_url="/path/to/conv2.jsonl",
                    files=["c.py"],
                )

                traces = store.list_traces_for_conversation("/path/to/conv1.jsonl")
                assert len(traces) == 2
                assert {t.commit_sha for t in traces} == {"commit1", "commit2"}

            def test_trace_upsert(self, temp_sqlite):
                """Test that add_trace updates existing record."""
                from theo.storage.sqlite_store import SQLiteStore

                store = SQLiteStore(temp_sqlite)

                store.add_trace(
                    commit_sha="abc123",
                    conversation_url="/old/path.jsonl",
                    files=["old.py"],
                )
                store.add_trace(
                    commit_sha="abc123",
                    conversation_url="/new/path.jsonl",
                    files=["new.py"],
                )

                trace = store.get_trace("abc123")
                assert trace.conversation_url == "/new/path.jsonl"
                assert trace.files == ["new.py"]


        class TestCommitHook:
            """Tests for commit hook script."""

            def test_hook_importable(self):
                """Test that hook script can be imported."""
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent / "hooks"))

                # Should not raise
                import theo_commit_hook  # noqa: F401


        # Fixture for temp SQLite (add to conftest.py if not exists)
        @pytest.fixture
        def temp_sqlite(tmp_path):
            """Create temporary SQLite database."""
            return tmp_path / "test.db"
        ```

        Run ./check --fix after changes.
        </task_description>

      implementation:
        approach: "Create pytest test file with fixtures"
        key_points:
          - point: "test_trace_storage tests add_trace and get_trace"
            details: "Tests add_trace and get_trace roundtrip in TestTraceStorage class"
            reference: "tests/test_agent_trace.py:TestTraceStorage"
          - point: "test_trace_list_by_conversation tests list_traces_for_conversation"
            details: "Tests filtering by conversation URL"
            reference: "tests/test_agent_trace.py:TestTraceStorage"
          - point: "test_commit_hook_script tests theo-commit-hook.py can be imported"
            details: "Verifies hook script has no syntax errors"
            reference: "tests/test_agent_trace.py:TestCommitHook"
          - point: "test_daemon_active_session tests get_active_session command"
            details: "Tests daemon command handler"
            reference: "tests/test_agent_trace.py"
          - point: "./check --fix passes"
            details: "All quality checks pass"
            reference: "tests/test_agent_trace.py"
          - point: "All tests pass"
            details: "pytest tests/test_agent_trace.py -v runs successfully"
            reference: "tests/test_agent_trace.py"

      code_quality:
        python:
          full_quality_pipeline:
            command: "cd /Users/harrison/Documents/Github/theo && ./check --fix"
            exit_on_failure: true

      commit:
        type: "test"
        message: "Add integration tests for Agent Trace"
        files: ["tests/test_agent_trace.py"]
